Program.Sub.Preflight.Start
Program.Sub.Preflight.End

Program.Sub.Main.Start
'GCG_6098_ImportBatches.g2u
'Trey S
'September 16th, 2020
'For Thomas Instruments
'Quote 12327-0
'Ticket 230520-6920201231-0
'This program will read all files from the directory set in the maintenance menu and upload them
'File processing / uploading code was pulled from 5160

F.Intrinsic.Control.Try

V.Local.sMessage.Declare(String)

'check if supposed to be running
F.Intrinsic.Control.CallSub(GetSetting, "SETTING", "INTEGRATION_ENABLED", "DEFAULT", False)
F.Intrinsic.Control.If(V.Args.Setting)

	'check if already running
	F.Intrinsic.Control.CallSub(ScriptPIDCheck, "PROJECT", "6098", "TASK", "GCG_6098_ImportBatches")
	
	'check if valud path set up
	F.Intrinsic.Control.CallSub(CheckPath)
	F.Intrinsic.Control.If(V.Args.VALID_PATH)
		F.Intrinsic.Control.CallSub(ProcessFiles, "PATH", V.Args.Path)
	F.Intrinsic.Control.Else
		'write log
		F.Intrinsic.String.Build("Set AP batch import path [{0}] is invalid or empty. Please set a proper path in Accounts Payable > Administration > Concur Cloud Snap Integration Settings [6098]. No processing will be done.", V.Local.sFullFile, V.Local.sMessage)
		F.Intrinsic.Control.CallSub(UnattendedErrorMessage, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
	F.Intrinsic.Control.EndIf
	
	'done
	F.Intrinsic.Control.CallSub(Exit)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.Main.End

Program.Sub.Exit.Start
F.Intrinsic.Control.Try

F.Intrinsic.Control.CallSub(Connection, "Connect", False)

F.Intrinsic.Control.CallSub(ScriptPIDClear, "PROJECT", "6098", "TASK", "GCG_6098_ImportBatches")

F.Intrinsic.Control.End

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.Exit.End

Program.Sub.GetBranch.Start
'returns BRANCH

F.Intrinsic.Control.Try

V.Local.sSQL.Declare(String)
V.Local.sRet.Declare(String)

F.Intrinsic.String.Build("select RTRIM(BRANCH_ID) from V_ACCTG_BRANCH where CO_CODE = '{0}'", V.Caller.CompanyCode, V.Local.sSQL)

F.Intrinsic.Control.CallSub(Connection, "Connect", True)
F.ODBC.Connection!Con.ExecuteAndReturn(V.Local.sSQL, V.Local.sRet)
F.Intrinsic.Control.CallSub(Connection, "Connect", False)

'if no branch is set up, we use NA
F.Intrinsic.Control.If(V.Ambient.ExecuteAndReturnEOF)
	V.Local.sRet.Set("NA")
F.Intrinsic.Control.Else
	F.Intrinsic.Control.If(V.Local.sRet.Trim, =, "")
		V.Local.sRet.Set("NA")
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

F.Intrinsic.Variable.AddRV("BRANCH", V.Local.sRet)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.GetBranch.End

Program.Sub.ProcessFiles.Start
F.Intrinsic.Control.Try

V.Local.iCounter.Declare(Long)
V.Local.sFileList.Declare(String)
V.Local.sFullFile.Declare(String)
V.Local.sExtension.Declare(String)
V.Local.sPath.Declare(String)
V.Local.sTempFile.Declare(String)
V.Local.sProcessedPath.Declare(String)
V.Local.sFailedPath.Declare(String)
V.Local.sInvalidPath.Declare(String)
V.Local.sMessage.Declare(String)

F.Intrinsic.Control.CallSub(GetBranch)

F.Intrinsic.Control.If(V.Args.Path.Right1, !=, "/", AND, V.Args.Path.Right1, !=, "\")
	F.Intrinsic.String.Build("{0}\", V.Args.Path, V.Local.sPath)
F.Intrinsic.Control.Else
	V.Local.sPath.Set(V.Args.Path)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("{0}Processed\", V.Local.sPath, V.Local.sProcessedPath)
F.Intrinsic.String.Build("{0}Failed\", V.Local.sPath, V.Local.sFailedPath)
F.Intrinsic.String.Build("{0}Invalid\", V.Local.sPath, V.Local.sInvalidPath)

'get all files in the import path, loop through them
F.Intrinsic.File.GetFileList(V.Local.sPath, V.Local.sFileList)
F.Intrinsic.Control.If(V.Local.sFileList.Trim, !=, "")
	F.Intrinsic.String.Split(V.Local.sFileList, ":", V.Local.sFileList)
	
	F.Intrinsic.String.Build("{0} files found in import directory to be uploaded...", V.Local.sFileList.UBound++, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
	
	F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sFileList.UBound, 1)
	
		F.Intrinsic.File.GetExtensionComponent(V.Local.sFileList(V.Local.iCounter), V.Local.sExtension)
		F.Intrinsic.String.Build("{0}{1}", V.Local.sPath, V.Local.sFileList(V.Local.iCounter), V.Local.sFullFile)
		
		F.Intrinsic.Control.CallSub(AppendFileName, "File", V.Local.sFileList(V.Local.iCounter), "APPEND", V.Ambient.Now.FormatYYYY-MM-DD-HH-NN-SS)
		V.Local.sTempFile.Set(V.Args.New_Name)
		
		F.Intrinsic.String.Build("Processing file [{0}]", V.Local.sFullFile, V.Local.sMessage)
		F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
		
		F.Intrinsic.Control.If(V.Local.sExtension.UCase, =, "CSV")
			'process file
			F.Intrinsic.Control.CallSub(FileToDataTable, "File", V.Local.sFullFile)
			F.Intrinsic.Control.CallSub(CheckMatches)
			F.Intrinsic.Control.CallSub(UploadBatch, "BRANCH", V.Args.BRANCH, "FAIL_PATH", V.Local.sFailedPath, "File", V.Local.sFullFile)
			
			'move file to processed folder
			F.Intrinsic.Control.If(V.Args.Failed.Not)
				F.Intrinsic.Control.CallSub(MoveFile, "File", V.Local.sFullFile, "NEW_PATH", V.Local.sProcessedPath, "NEW_NAME", V.Local.sTempFile)
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.Else
			'write log
			F.Intrinsic.String.Build("File [{0}] is invalid type [{1}] for processing. Expected CSV. Skipping...", V.Local.sFullFile, V.Local.sExtension, V.Local.sMessage)
			F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
			
			'move to failed directory
			F.Intrinsic.Control.CallSub(MoveFile, "File", V.Local.sFullFile, "NEW_PATH", V.Local.sInvalidPath, "NEW_NAME", V.Local.sTempFile)
		F.Intrinsic.Control.EndIf
		
		F.Intrinsic.String.Build("Processing complete for file [{0}]", V.Local.sFullFile, V.Local.sMessage)
		F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
		
	F.Intrinsic.Control.Next(V.Local.iCounter)
	
	F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", "Processing complete.")
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.ProcessFiles.End

Program.Sub.FileToDatatable.Start
'pass FILE

F.Intrinsic.Control.Try

V.Local.iC.Declare(Long)
V.Local..BulkDeclareString(sFile,sRet,sTypes,sFields, sdd, smm, syy)
V.Local.bExists.Declare(Boolean, False)

V.Local.sFile.Set(V.Args.FILE)

F.Intrinsic.File.File2String(V.Local.sFile, V.Local.sRet)

V.Local.sTypes.Set("String*!*String*!*String*!*String*!*String*!*String*!*String*!*String")
V.Local.sFields.Set("PONo3*!*SentPOLine*!*PartNo*!*InvoiceDate*!*InvoiceNo*!*Qty*!*UnitPrice*!*BalanceDueString")
F.Data.DataTable.CreateFromString("APTemp", V.Local.sRet, V.Local.sFields , V.Local.sTypes,",",V.Ambient.NewLine, True)

'delete header line
F.Data.DataTable.DeleteRow("APTemp", 0)

'delete empty lines
F.Data.DataView.Create("APTemp", "dvAPTemp", 22, "IsNull(PONo3, '') <> ''", "")
F.Data.DataView.ToDataTable("APTemp", "dvAPTemp", "AP", True)
F.Data.DataView.Close("APTemp", "dvAPTemp")
F.Data.DataTable.Close("APTemp")

F.Intrinsic.Control.For(V.Local.iC, 0, V.DataTable.AP.RowCount--, 1)
	F.Intrinsic.String.Split(V.Datatable.AP(V.Local.iC).InvoiceDate!FieldValTrim, "/", V.Local.sRet)
	F.Intrinsic.String.LPad(V.Local.sRet(0), "0", 2, V.Local.smm)
	F.Intrinsic.String.LPad(V.Local.sRet(1), "0", 2, V.Local.sdd)
	F.Intrinsic.String.Right(V.Local.sRet(2), 2, V.Local.syy)
	F.Intrinsic.String.Build("{0}{1}{2}", V.Local.smm, V.Local.sdd, V.Local.syy, V.Local.sRet)
	F.Data.DataTable.SetValue("AP", V.Local.iC, "InvoiceDate", V.Local.sRet)
F.Intrinsic.Control.Next(V.Local.iC)

'balance from string to float
F.Data.DataTable.AddExpressionColumn("AP", "BalanceDue", "Float", "BalanceDueString")
'first create to lose 0 padding
F.Data.DataTable.AddExpressionColumn("AP", "PONo2", "Long", "PONo3")
'then back to string
F.Data.DataTable.AddExpressionColumn("AP", "PONo1", "String", "PONo2")

F.Data.DataTable.AddExpressionColumn("AP", "PONo", "string","IIF(Len(PONo1) = 1,  '000000'+PONo1, IIF	(Len(PONo1) = 2, '00000'+PONo1,IIF(Len(PONo1) = 3, '0000'+PONo1,IIF(Len(PONo1) = 4, '000'+PONo1,IIF(Len(PONo1) = 5, '00'+PONo1,IIF(Len(PONo1) = 6, '0'+PONo1, PONo1))))))")

F.Data.DataTable.AddExpressionColumn("AP", "POLine", "string","IIF(Len(TRIM(SentPOLine)) = 1,'00'+SentPOLine,IIF(Len(Trim(SentPOLine)) = 2,'0'+SentPOLine,SentPOLine))")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.FileToDatatable.End

Program.Sub.CheckMatches.Start
F.Intrinsic.Control.Try

V.Local.sRet.Declare(String)
V.Local.sFilePath.Declare(String)
V.Local.sDate.Declare(String)
V.Local.sParams.Declare(string)

F.Intrinsic.Control.CallSub(Connection, "Connect", True)
F.Data.DataTable.CreateFromSQL("PO", "con", "Select rTrim(PURCHASE_ORDER) As PURCHASE_ORDER, RTRIM(PO_LINE) as PO_LINE, Concat(rTrim(PURCHASE_ORDER),RTRIM(PO_LINE)) as PONoLine , rTrim(PART) as PART, (EXTENDED_COST+5) As EXTENSIONPlus5, (EXTENDED_COST-5) As EXTENSIONMinus5, EXTENDED_COST, QTY_RECEIVED, VENDOR, RECEIVER_NO as RECEIVER From V_PO_RECEIVER")

F.Data.Linq.Join("LeftJoin", "Datatable", "AP*!*AP",  "Datatable", "PO*!*PO", "AP.PONo=PO.PURCHASE_ORDER And AP.POLine=PO.PO_LINE","AP.PONo*!*PO.PO_LINE*!*PO.PONoLine*!*PO.PART as PartNo*!*AP.InvoiceDate*!*AP.InvoiceNo*!*AP.Qty*!*PO.EXTENDED_COST*!*PO.EXTENSIONPlus5*!*PO.EXTENSIONMinus5*!*AP.BalanceDue*!*PO.QTY_RECEIVED*!*PO.VENDOR*!*PO.RECEIVER*!*PO.PURCHASE_ORDER", "", "", "", "BATCH", True)

F.Data.DataTable.Close("PO")
F.Data.DataTable.Close("AP")

'check invoices
F.Data.DataTable.AddColumn("BATCH", "INVOICE", "string")
F.Data.Dictionary.CreateFromSQL("dict","con","Select  rTrim(INVC) As InvoiceNo, rTrim(INVC) As INVOICE From AP_OPEN_BATCHES")
F.Data.Dictionary.SetDefaultReturn("dict", "")
F.Data.DataTable.FillFromDictionary("BATCH", "dict", "InvoiceNo", "INVOICE")
F.Data.Dictionary.Close("dict")

'check PO in AP_open_items
F.Data.DataTable.AddColumn("BATCH", "PURCHASE_ORDER_OP_IT", "string")
F.Data.Dictionary.CreateFromSQL("dict","con","Select  rTrim(PURCHASE_ORDER) As PONo, rTrim(PURCHASE_ORDER) As PURCHASE_ORDER_OP_IT From AP_OPEN_ITEMS")
F.Data.Dictionary.SetDefaultReturn("dict", "")
F.Data.DataTable.FillFromDictionary("BATCH", "dict", "PURCHASE_ORDER", "PURCHASE_ORDER_OP_IT")
F.Data.Dictionary.Close("dict")

'Check qyt on PO for comparison to what was received. if qty on PO greater than Qty Received then the batch upload will not work.
F.Data.DataTable.AddColumn("BATCH", "QTY_OPEN_ONPO", "float")
F.Data.Dictionary.CreateFromSQL("dict","con","Select  Concat(rTrim(PURCHASE_ORDER) ,Left(rTrim(Record_no),3)) As PONoLine,(Qty_Order - QTY_Received) as QTY_OPEN_ONPO From V_PO_LINES")
F.Data.Dictionary.SetDefaultReturn("dict", 0)
F.Data.DataTable.FillFromDictionary("BATCH", "dict", "PONoLine", "QTY_OPEN_ONPO")
F.Data.Dictionary.Close("dict")

F.Intrinsic.Control.CallSub(Connection, "Connect", False)

F.Data.DataTable.AddExpressionColumn("BATCH", "PriceMismatch", "String", "IIF(BalanceDue >EXTENSIONMinus5 And BalanceDue < EXTENSIONPlus5, 'N', 'Y')" )
F.Data.DataTable.AddExpressionColumn("BATCH", "POnotFound", "String", "IsNull(PURCHASE_ORDER_OP_IT, 'Y')")
F.Data.DataTable.AddExpressionColumn("BATCH", "InvoiceRepeat", "String", "IIF(INVOICE = '', 'N', 'Y')")
F.Data.DataTable.AddExpressionColumn("BATCH", "OpenQtyOnPO", "String", "IIF(QTY_OPEN_ONPO > 0, 'Y', 'N')")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.CheckMatches.End

Program.Sub.UploadBatch.Start
'pass BRANCH
'pass FAIL_PATH
'pass FILE

F.Intrinsic.Control.Try

V.Local.sRet.Declare(String)
V.Local.sFilePath.Declare(String)
V.Local.sDate.Declare(String)
V.Local.sParams.Declare(string)
V.Local.sMessage.Declare(String)
V.Local.sFailedRecords.Declare(String)
V.Local.sFileName.Declare(String)
V.Local.iFailed.Declare(Long)
V.Local.iSuccess.Declare(Long)
V.Local.sContents.Declare(String)
V.Local.bFailed.Declare(Boolean, False)
V.Local.sMap.Declare(String, "BatchDate*!*VENDOR*!*INVOICENO*!*InvoiceDate*!*INVOICE-DUE-DATE*!*BalanceDue*!*GL_ACCOUNT_LINE*!*TAXABLE_FLAG*!*TAX_CODE*!*BOOK_SELF_ACCESS_TAX*!*WORK_ORDER*!*WORK_SUFF*!*WORK_SEQ*!*BRANCH*!*POno*!*PO_LINE*!*PURCHASE_ORDER_UNIT _OF_MEASURE*!*RECEIVER*!*Qty*!*UnitPrice*!*BUYER*!*VOUCHER*!*VAT_TAX_RULE*!*PARTLOCATION*!*COST-TYPE*!*INVOICE-NOTES")

'Add Batch Date
V.Local.sDate.Set(V.Ambient.Date)
F.Intrinsic.String.Format(V.Local.sDate,"MMDDYY",V.Local.sDate)
F.Data.DataTable.AddColumn("BATCH", "BatchDate", "String", V.Local.sDate)
V.Local.sDate.Set(V.Ambient.Date)
F.Intrinsic.String.Format(V.Local.sDate,"YYYYMMDD",V.Local.sDate)

F.Data.DataTable.AddColumn("BATCH", "GL_ACCOUNT_LINE", "String", "")
F.Data.DataTable.AddColumn("BATCH", "UnitPrice", "String", "")
F.Data.DataTable.AddColumn("BATCH", "INVOICE-DUE-DATE", "String", "")
F.Data.DataTable.AddColumn("BATCH", "TAXABLE_FLAG", "String", "")
F.Data.DataTable.AddColumn("BATCH", "TAX_CODE", "String", "")
F.Data.DataTable.AddColumn("BATCH", "BOOK_SELF_ACCESS_TAX", "String", "")
F.Data.DataTable.AddColumn("BATCH", "WORK_ORDER", "String", "")
F.Data.DataTable.AddColumn("BATCH", "WORK_SUFF", "String", "")
F.Data.DataTable.AddColumn("BATCH", "WORK_SEQ", "String", "")
F.Data.DataTable.AddColumn("BATCH", "BRANCH", "String", V.Args.Branch.Trim)
F.Data.DataTable.AddColumn("BATCH", "PURCHASE_ORDER_UNIT _OF_MEASURE", "String", "")
F.Data.DataTable.AddColumn("BATCH", "BUYER", "String", "")
F.Data.DataTable.AddColumn("BATCH", "VOUCHER", "String", "")
F.Data.DataTable.AddColumn("BATCH", "VAT_TAX_RULE", "String", "")
F.Data.DataTable.AddColumn("BATCH", "PARTLOCATION", "String", "")
F.Data.DataTable.AddColumn("BATCH", "COST-TYPE", "String", "")
F.Data.DataTable.AddColumn("BATCH", "INVOICE-NOTES", "String", "")

F.Data.DataView.Create("BATCH", "dvBatchUp", 22, "PriceMismatch = 'N' AND POnotFound<> '' AND InvoiceRepeat = 'N' AND OpenQtyOnPO = 'N'", "")
V.Local.iSuccess.Set(V.DataView.Batch!dvBatchUp.RowCount)
F.Data.DataView.ToString("BATCH", "dvBatchUp", V.Local.sMap, "*!*", V.Ambient.NewLine, V.Local.sRet)
F.Data.DataView.SetFilter("BATCH", "dvBatchUp", "PriceMismatch <> 'N' or POnotFound = '' or InvoiceRepeat <> 'N' or OpenQtyOnPO <> 'N'")
V.Local.iFailed.Set(V.DataView.Batch!dvBatchUp.RowCount)
F.Data.DataView.ToString("BATCH", "dvBatchUp", V.Local.sMap, "*!*", V.Ambient.NewLine, V.Local.sFailedRecords)
F.Data.DataView.Close("BATCH", "dvBatchUp")
F.Data.DataTable.Close("BATCH")

F.Intrinsic.Control.If(V.Local.sRet.Trim, !=, "")

	'write any failed records
	F.Intrinsic.Control.If(V.Local.sFailedRecords.Trim, !=, "")
		F.Intrinsic.String.Build("{0}FailedRecords_{1}.csv", V.Args.Fail_Path, V.Ambient.Now.FormatYYYY-MM-DD-HH-NN-SS, V.Local.sFileName)
		F.Intrinsic.String.Build("{0}{1}{2}", V.Local.sMap, V.Ambient.NewLine, V.Local.sFailedRecords, V.Local.sFailedRecords)
		
		F.Intrinsic.String.Build("{0} invalid records found in file [{1}]. Writing to [{2}].", V.Local.iFailed, V.Args.File, V.Local.sFileName, V.Local.sMessage)
		F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
		
		F.Intrinsic.File.String2File(V.Local.sFileName, V.Local.sFailedRecords)
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.String.Concat(V.caller.FilesDir,"\APBATCH_INVACR", V.Args.Branch.Trim, ".txt", V.Local.sFilePath)
	F.Intrinsic.File.String2File(V.Local.sFilePath,V.Local.sRet)
	
	F.Intrinsic.Control.CallSub(GetNextBatchNumber)
	
	F.Intrinsic.String.Build("APBATCH_INVACR{0}.txt!*!{1}!*!{2}!*!{3}",V.Args.Branch.Trim,V.Caller.User,V.Args.Next_Batch,V.Local.sDate,V.Local.sParams)
	'F.Intrinsic.Debug.CallWrapperDebugEnable
	
	F.Intrinsic.String.Build("{0} valid records found in file [{1}], Writing to text file [{2}] and running callwrapper 2110.", V.Local.iSuccess, V.Args.File, V.Local.sFilePath, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
	F.Intrinsic.String.Build("Uploading as batch number [{0}] for branch [{1}].", V.Args.Next_Batch.Trim, V.Args.Branch.Trim, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)

	F.Global.General.CallWrapperSync(2110,V.Local.sParams)
F.Intrinsic.Control.Else
	'file failed, write log, move file
	F.Intrinsic.String.Build("No valid records found in file [{0}]. Failing...", V.Args.File, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
	
	F.Intrinsic.File.GetFileNameFromFQN(V.Args.File, V.Local.sFileName)
	F.Intrinsic.Control.CallSub(AppendFileName, "File", V.Local.sFileName, "Append", V.Ambient.Now.FormatYYYY-MM-DD-HH-NN-SS)
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.File, "NEW_PATH", V.Args.Fail_Path, "NEW_NAME", V.Args.New_Name)
	
	V.Local.bFailed.Set(True)
F.Intrinsic.Control.EndIf

F.Intrinsic.Variable.AddRV("FAILED", V.Local.bFailed)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.UploadBatch.End

Program.Sub.AppendFileName.Start
'pass FILE
'pass APPEND
'returns NEW_NAME

F.Intrinsic.Control.Try

V.Local.sExtension.Declare(String)
V.Local.sFile.Declare(String)
V.Local.sNewName.Declare(String)

F.Intrinsic.File.GetExtensionComponent(V.Args.File, V.Local.sExtension)
F.Intrinsic.String.Build(".{0}", V.Local.sExtension, V.Local.sExtension)
F.Intrinsic.String.Replace(V.Args.File, V.Local.sExtension, "", V.Local.sNewName)
F.Intrinsic.String.Build("{0}_{1}{2}", V.Local.sNewName, V.Args.Append, V.Local.sExtension, V.Local.sNewName)

F.Intrinsic.Variable.AddRV("NEW_NAME", V.Local.sNewName)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.AppendFileName.End

Program.Sub.CheckPath.Start
'returns VALID_PATH, PATH

F.Intrinsic.Control.Try

V.Local.bValid.Declare(Boolean, False)

F.Intrinsic.Control.CallSub(GetSetting, "Setting", "AP_BATCH_IMPORT_PATH", "DEFAULT", "")
F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
	F.Intrinsic.File.DirExists(V.Args.Setting.Trim, V.Local.bValid)
F.Intrinsic.Control.EndIf

F.Intrinsic.Variable.AddRV("VALID_PATH", V.Local.bValid)
F.Intrinsic.Variable.AddRV("PATH", V.Args.Setting.Trim)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.CheckPath.End

Program.Sub.GetNextBatchNumber.Start
'returns NEXT_BATCH

F.Intrinsic.Control.Try

V.Local.sSQl.Declare(String)
V.Local.iRet.Declare(Long)
V.Local.sRet.Declare(String)

V.Local.ssql.Set("Select top 1 Right(BATCH, 4) as Batch From GL_BATCH_LOG where Left(Batch,1)= 'P' order by Right(BATCH, 4) desc")
Function.ODBC.Connection!con.OpenCompanyConnection
Function.ODBC.Connection!con.ExecuteAndReturn(V.Local.ssql, V.Local.iRet)
Function.ODBC.Connection!con.Close

F.Intrinsic.Math.Add(V.Local.iRet, 1, V.Local.iRet)
F.Intrinsic.String.LPad(V.Local.iRet, "0", 4,V.Local.sRet)
F.Intrinsic.String.Build("P{0}", V.Local.sRet, V.Local.sRet)

F.Intrinsic.Variable.AddRV("NEXT_BATCH", V.Local.sRet)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.GetNextBatchNumber.End

Program.Sub.GetSetting.Start
'pass SETTING
'pass DEFAULT
'returns SETTING

F.Intrinsic.Control.Try

V.Local.sSQL.Declare(String)
V.Local.sRet.Declare(String)
V.Local.sSetting.Declare(String)

F.Intrinsic.String.Build("select RTRIM(VALUE) from GCG_6098_SETTINGS where NAME = '{0}'", V.Args.Setting, V.Local.sSQL)

F.Intrinsic.Control.CallSub(Connection, "Connect", True)
F.ODBC.Connection!Con.ExecuteAndReturn(V.Local.sSQL, V.Local.sRet)
F.Intrinsic.Control.CallSub(Connection, "Connect", False)

F.Intrinsic.Control.If(V.Ambient.ExecuteAndReturnEOF)
	V.Local.sSetting.Set(V.Args.Default)
F.Intrinsic.Control.Else
	F.Intrinsic.Control.If(V.Local.sRet.Trim, =, "")
		V.Local.sSetting.Set(V.Args.Default)
	F.Intrinsic.Control.Else
		V.Local.sSetting.Set(V.Local.sRet.Trim)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

F.Intrinsic.Variable.AddRV("SETTING", V.Local.sSetting)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.GetSetting.End

Program.Sub.MoveFile.Start
'move file to the given directory
'create the directory if it doesn't exist
'if file already exists there, add a suffix
'pass FILE, NEW_PATH, NEW_NAME (Optional, if name changing)

F.Intrinsic.Control.Try

V.Local.sFile.Declare(String)
V.Local.sNewPath.Declare(String)
V.Local.bExists.Declare(boolean)
V.Local.iCounter.Declare(Long, 0)
V.Local.sFileName.Declare(String)
V.Local.sNewFile.Declare(String)
V.Local.sNewFileTemp.Declare(String)
V.Local.sSlash.Declare(String, "")
V.Local.bMoved.Declare(Boolean)
V.Local.sNewName.Declare(String, "")
V.Local.sMessage.Declare(String)

V.Local.sFile.Set(V.Args.FILE)
V.Local.sNewPath.Set(V.Args.NEW_PATH)
F.Intrinsic.Variable.ArgExists("NEW_NAME", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	V.Local.sNewName.Set(V.Args.NEW_NAME)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.CallSub(CheckDirectories, "DIRECTORIES", V.Local.sNewPath)

F.Intrinsic.Control.If(V.Local.sNewPath.Right1, !=, "\")
	V.Local.sSlash.Set("\")
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.If(V.Local.sNewName.Trim, =, "")
	F.Intrinsic.File.GetFileNameFromFQN(V.Local.sFile, V.Local.sFileName)
F.Intrinsic.Control.Else
	V.Local.sFileName.Set(V.Local.sNewName)
F.Intrinsic.Control.EndIf
F.Intrinsic.String.Build("{0}{1}{2}", V.Local.sNewPath, V.Local.sSlash, V.Local.sFileName, V.Local.sNewFile)

F.Intrinsic.File.Exists(V.Local.sNewFile, V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	F.Intrinsic.Control.DoUntil(V.Local.bExists.Not)
		F.Intrinsic.Math.Add(V.Local.iCounter, 1, V.Local.iCounter)
		F.Intrinsic.String.Split(V.Local.sNewFile, ".", V.Local.sNewFileTemp)
		F.Intrinsic.String.Build("{0}_{1}", V.Local.sNewFileTemp(0), V.Local.iCounter, V.Local.sNewFileTemp(0))
		F.Intrinsic.String.Join(V.Local.sNewFileTemp, ".", V.Local.sNewFileTemp)
		F.Intrinsic.File.Exists(V.Local.sNewFileTemp, V.Local.bExists)
	F.Intrinsic.Control.Loop
	V.Local.sNewFile.Set(V.Local.sNewFileTemp)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("Moving file [{0}] to [{1}]", V.Local.sFile, V.Local.sNewFile, V.Local.sMessage)
F.Intrinsic.Control.CallSub(AddLog, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Message", V.Local.sMessage)
F.Intrinsic.File.MoveFile(V.Local.sFile, V.Local.sNewFile, V.Local.bMoved)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.MoveFile.End

Program.Sub.Connection.Start
'open or close connection if necessary, keep track of all connections

F.Intrinsic.Control.Try

V.Static.iConnections.Declare(Long)

F.Intrinsic.Control.If(V.Args.Connect)
	F.Intrinsic.Control.If(V.Static.iConnections, =, 0)
		F.ODBC.Connection!Con.OpenCompanyConnection
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.Math.Add(V.Static.iConnections, 1, V.Static.iConnections)
F.Intrinsic.Control.Else
	F.Intrinsic.Control.If(V.Static.iConnections, >, 0)
		F.Intrinsic.Math.Sub(V.Static.iConnections, 1, V.Static.iConnections)
		
		F.Intrinsic.Control.If(V.Static.iConnections, =, 0)
			F.ODBC.Connection!Con.Close
		F.Intrinsic.Control.EndIf
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.Connection.End

Program.Sub.CheckDirectories.Start
'check if the given import directories exist
'create them if they don't
'pass directories delimited with *!*

F.Intrinsic.Control.Try

V.Local.sDirectories.Declare(String)
V.Local.sPath.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.iCounter.Declare(Long)

V.Local.sDirectories.Set(V.Args.Directories)
F.Intrinsic.String.Split(V.Local.sDirectories, "*!*", V.Local.sDirectories)

F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sDirectories.UBound, 1)
	V.Local.sPath.Set(V.Local.sDirectories(V.Local.iCounter))
	F.Intrinsic.File.DirExists(V.Local.sPath, V.Local.bExists)
	F.Intrinsic.Control.If(V.Local.bExists.Not)
		F.Intrinsic.File.CreateDir(V.Local.sPath)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.CheckDirectories.End

Program.Sub.AddLog.Start
'pass a project #, and a message
'date and time will be automatically added
'pass PROJECT (Folder)
'TASK what to name log
'MESSAGE (what to log)

F.Intrinsic.Control.Try

V.Local.sProject.Declare(String)
V.Local.sMessage.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.sPath.Declare(String)
V.Local.sFile.Declare(String)
V.Local.sContents.Declare(String)
V.Local.sTask.Declare(String)

V.Local.sProject.Set(V.Args.Project.Trim)
V.Local.sMessage.Set(V.Args.Message.Trim)
V.Local.sTask.Set(V.Args.Task)

F.Intrinsic.String.Replace(V.Local.sMessage, V.Ambient.NewLine, ", ", V.Local.sMessage)

F.Intrinsic.File.MakeFilenameFriendly(V.Local.sProject, V.Local.sProject)
F.Intrinsic.String.Build("{0}\Custom\{1}\{2}\Log", V.Caller.GlobalDir, V.Local.sProject, V.Caller.CompanyCode, V.Local.sPath)
F.Intrinsic.Control.CallSub(CheckDirectories, "DIRECTORIES", V.Local.sPath)

F.Intrinsic.String.Build("{0}\{1}_Log.txt", V.Local.sPath, V.Local.sTask, V.Local.sFile)
F.Intrinsic.File.Exists(V.Local.sFile, V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists.Not)
	F.Intrinsic.String.Build("{0} {1}:{2}Log Start", V.Ambient.Date.FormatYYYY-MM-DD, V.Ambient.Time, V.Ambient.Tab, V.Local.sContents)
	F.Intrinsic.File.String2File(V.Local.sFile, V.Local.sContents)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("{0} {1}:{2}{3}", V.Ambient.Date.FormatYYYY-MM-DD, V.Ambient.Time, V.Ambient.Tab, V.Local.sMessage, V.Local.sContents)
F.Intrinsic.File.Append2FileNewLine(V.Local.sFile, V.Local.sContents)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.AddLog.End

Program.Sub.AddLogFile.Start
'pass a project #, and a message
'date and time will be automatically added
'pass PROJECT (Folder)
'pass type (subfolder)
'MESSAGE (what to log)

F.Intrinsic.Control.Try

V.Local.sProject.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.sPath.Declare(String)
V.Local.sFile.Declare(String)
V.Local.sContents.Declare(String)
V.Local.sName.Declare(String)

F.Intrinsic.File.MakeFilenameFriendly(V.Args.Project, V.Local.sProject)
F.Intrinsic.String.Build("{0}\Custom\{1}\{2}\Log\{3}\", V.Caller.GlobalDir, V.Local.sProject, V.Caller.CompanyCode, V.Args.Type, V.Local.sPath)
F.Intrinsic.Control.CallSub(CheckDirectories, "DIRECTORIES", V.Local.sPath)

F.Intrinsic.String.StripCharacters(V.Ambient.Now, V.Local.sName)

F.Intrinsic.String.Build("{0}\{1}_Log.txt", V.Local.sPath, V.Local.sName, V.Local.sFile)
F.Intrinsic.File.String2File(V.Local.sFile, V.Args.Message.Trim)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.AddLogFile.End

Program.Sub.UnattendedErrorMessage.Start
'send a short error message, add the log
'pass project ID, project title (for message box title), and error message

F.Intrinsic.Control.Try

V.Local.sMessage.Declare(String)

V.Local.sMessage.Set(V.Args.Message.Trim)
F.Intrinsic.String.Replace(V.Local.sMessage, V.Ambient.NewLine, ", ", V.Local.sMessage)

F.Intrinsic.UI.InvokeWaitDialog(V.Local.sMessage, V.Args.ProjectTitle)
F.Intrinsic.UI.Sleep(10)
F.Intrinsic.UI.CloseWaitDialog

F.Intrinsic.Control.CallSub(AddLog, "Project", V.Args.Project, "TASK", V.Args.Task, "Message", V.Local.sMessage)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.UnattendedErrorMessage.End

Program.Sub.ScriptPIDCheck.Start
'check if the process is already running
'store PID in a text file
'Pass folder to store in 	- PROJECT
'what to name file			- TASK

F.Intrinsic.Control.Try

V.Local.bExists.Declare(Boolean)
V.Local.sDir.Declare(String)
V.Local.sCurrentPIDProcess.Declare(String)
V.Local.sFile.Declare(String)
V.Local.sProject.Declare(String)
V.Local.sTask.Declare(String)
V.Local.bRunning.Declare(Boolean, False)
V.Local.bPIDRunning.Declare(Boolean, False)
V.Local.sContents.Declare(String)

V.Local.sProject.Set(V.Args.Project)
V.Local.sTask.Set(V.Args.Task)

'check if running file exists
F.Intrinsic.String.Build("{0}\Custom\{1}\{2}\IS_RUNNING\{3}_Running.dat", V.Caller.GlobalDir, V.Local.sProject, V.Caller.CompanyCode, V.Local.sTask, V.Local.sFile)
F.Intrinsic.File.Exists(V.Local.sFile, V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	'check if file / PID is valid
	F.Intrinsic.File.File2String(V.Local.sFile, V.Local.sContents)
	F.Intrinsic.String.Split(V.Local.sContents, V.Ambient.NewLine, V.Local.sContents)
	F.Intrinsic.String.Replace(V.Local.sContents(0), "PID: ", "", V.Local.sCurrentPIDProcess)
	V.Local.sContents.Redim(0, 0)
	F.Intrinsic.Control.If(V.Local.sCurrentPIDProcess.Long, >, 0)
		'check if PID is actually running
		F.Intrinsic.Task.PIDRunning(V.Local.sCurrentPIDProcess.Long, V.Local.bPIDRunning)
		F.Intrinsic.Control.If(V.Local.bPIDRunning)
			'the program is running
			V.Local.bRunning.Set(True)
		F.Intrinsic.Control.EndIf
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.If(V.Local.bRunning)
	'if it's already running, end here
	F.Intrinsic.Control.End
F.Intrinsic.Control.Else
	'delete the file if it exists
	F.Intrinsic.Control.If(V.Local.bExists)
		F.Intrinsic.File.DeleteFile(V.Local.sFile)
	F.Intrinsic.Control.EndIf
	
	'create lock file contents
	F.Intrinsic.String.Build("PID: {0}{1}Launch Time: {2}{1}GSS User: {3}{1}Terminal: {4}{1}Windows User: {5}{1}Machine: {6}{1}Hook: {7}{1}Caller: {8}{1}Script: {9}{1}Company Code: {10}", V.Ambient.PID, V.Ambient.NewLine, V.Ambient.Now, V.Caller.User, V.Caller.Terminal, V.System.UserName, V.System.ComputerName, V.Caller.Hook, V.Caller.Caller, V.Caller.ScriptFile, V.Caller.CompanyCode, V.Local.sContents)
	
	'create a new lock file
	F.Intrinsic.String.Build("{0}\Custom\{1}\{2}\IS_RUNNING", V.Caller.GlobalDir, V.Local.sProject, V.Caller.CompanyCode, V.Local.sDir)
	F.Intrinsic.Control.CallSub(CheckDirectories, "Directories", V.Local.sDir)
	F.Intrinsic.String.Build("{0}\{1}_Running.dat", V.Local.sDir, V.Local.sTask, V.Local.sFile)
	F.Intrinsic.File.String2File(V.Local.sFile, V.Local.sContents)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.ScriptPIDCheck.End

Program.Sub.ScriptPIDClear.Start
'delete the is running file, so the next time the program runs it knows it isn't currently running
'Pass folder to store in 	- PROJECT
'filename  base				- TASK

F.Intrinsic.Control.Try

V.Local.bExists.Declare(Boolean)
V.Local.sFile.Declare(String)
V.Local.sProject.Declare(String)
V.Local.sTask.Declare(String)

V.Local.sProject.Set(V.Args.Project)
V.Local.sTask.Set(V.Args.Task)

F.Intrinsic.String.Build("{0}\Custom\{1}\{2}\IS_RUNNING\{3}_Running.dat", V.Caller.GlobalDir, V.Local.sProject, V.Caller.CompanyCode, V.Local.sTask, V.Local.sFile)
F.Intrinsic.File.Exists(V.Local.sFile, V.Local.bExists)

F.Intrinsic.Control.If(V.Local.bExists)
	F.Intrinsic.File.DeleteFile(V.Local.sFile)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "WRITE_LOG_FILE", True, "Project", "6098", "Task", "GCG_6098_ImportBatches", "Unattended", True, "ProjectTitle", "6098 Concur Cloudsnap Integration", "Callback", "Exit")
F.Intrinsic.Control.EndTry
Program.Sub.ScriptPIDClear.End

Program.Sub.ErrorMessage.Start
'basic error message for replacing catch block
'this is really just for when printing the message and ending program
'pass error number, error description, current subroutine
'optional callback sub, this will be called before ending
'optional unattended parameters, those subs may not exist if not using them but won't be called

F.Intrinsic.Control.Try

V.Local.sError.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.sCallback.Declare(String)
V.Static.bError.Declare(Boolean, False)
V.Local.sDoubleNewLine.Declare(String)

'make sure we aren't in an error loop
F.Intrinsic.Control.If(V.Static.bError)
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndIf
V.Static.bError.Set(True)

F.Intrinsic.String.Build("{6}{1}{1}Project: {0}{1}{1}Subroutine: {2}{1}Error Occurred {3} with description {4}{1}{1}GAB Version: {5}", V.Caller.ScriptFile, V.Ambient.Newline, V.Args.Subroutine, V.Args.ErrorNumber, V.Args.ErrorDescription, V.Ambient.GABVersion, V.Ambient.Now, V.Local.sError)

F.Intrinsic.Variable.ArgExists("UNATTENDED", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	F.Intrinsic.Control.If(V.Args.UNATTENDED)
		F.Intrinsic.Control.CallSub(UnattendedErrorMessage, "MESSAGE", V.Local.sError, "PROJECT", V.Args.PROJECT, "PROJECTTITLE", V.Args.PROJECTTITLE, "TASK", V.Args.Task)
	F.Intrinsic.Control.Else
		F.Intrinsic.UI.Msgbox(V.Local.sError)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Else
	F.Intrinsic.UI.Msgbox(V.Local.sError)
F.Intrinsic.Control.EndIf

F.Intrinsic.Variable.ArgExists("WRITE_LOG_FILE", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	F.Intrinsic.Control.If(V.Args.WRITE_LOG_FILE)
		F.Intrinsic.String.Build("{0}{0}", V.Ambient.NewLine, V.Local.sDoubleNewLine)
		F.Intrinsic.String.Replace(V.Local.sError, V.Local.sDoubleNewLine, V.Ambient.NewLine, V.Local.sError)
		
		F.Intrinsic.String.Build("Time: {0}{1}User: {2}{1}Windows User: {3}{1}Machine: {4}{1}PID: {5}{1}Terminal: {6}{1}Caller: {7}{1}Synchronous: {8}{1}Thread ID: {9}{1}Pervasive Client: {10}{1}GAB Version: {11}{1}GSS Version: {12}{1}Error: {13}{1}Error Description: {14}{1}Script: {15}{1}Subroutine: {16}", V.Ambient.Now, V.Ambient.NewLine, V.Caller.User, V.System.UserName, V.System.ComputerName, V.Ambient.PID, V.Caller.Terminal, V.Caller.Caller, V.Caller.Sync,  V.Ambient.ThreadID, V.Ambient.PervasiveClientVersion, V.Ambient.GABVersion, V.Caller.GSSVersion, V.Args.ErrorNumber, V.Args.ErrorDescription, V.Caller.ScriptFile, V.Args.Subroutine, V.Local.sError)
		
		F.Intrinsic.Control.CallSub(AddLogFile, "PROJECT", V.Args.Project, "TYPE", V.Args.Task, "MESSAGE", V.Local.sError)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

F.Intrinsic.Variable.ArgExists("Callback", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	V.Local.sCallback.Set(V.Args.Callback.Trim)
	F.Intrinsic.Control.CallSub(V.Local.sCallback)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.End

F.Intrinsic.Control.Catch
	F.Intrinsic.String.Build("Project: {0}{1}{1}Subroutine: {2}{1}Error Occurred {3} with description {4}{1}{1}GAB Version: {5}",V.Caller.ScriptFile,V.Ambient.Newline,V.Ambient.CurrentSubroutine,V.Ambient.ErrorNumber,V.Ambient.ErrorDescription,V.Ambient.GABVersion,V.Local.sError)
	F.Intrinsic.UI.Msgbox(V.Local.sError)
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndTry
Program.Sub.ErrorMessage.End